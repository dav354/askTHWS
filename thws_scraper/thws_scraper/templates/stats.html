<!DOCTYPE html>
<html>

<head>
    <title>Live Crawler Stats</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #282828;
            color: #ebdbb2;
            font-size: 0.9em;
        }

        h1 {
            color: #83a598;
            border-bottom: 1px solid #504945;
            padding-bottom: 10px;
            margin-top: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #runningTimer {
            font-size: 0.65em;
            color: #928374;
            font-weight: normal;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            border: 1px solid #504945;
        }

        td {
            border: 1px solid #504945;
            padding: 6px 8px;
            text-align: center;
        }

        tr td:first-child {
            text-align: left;
            min-width: 150px;
        }

        #statsTableBody tr.dynamic-header-row td {
            background-color: #3c3836;
            color: #fabd2f;
            font-weight: bold;
        }

        #statsTableBody tr.dynamic-header-row td:first-child {
            text-align: left;
        }

        tr:not(.dynamic-header-row):hover {
            background-color: #3c3836;
        }

        .domain-name {
            color: #ebdbb2;
            font-weight: bold;
        }

        #summaryRow td {
            font-weight: bold;
            color: #d3869b;
            font-size: 1.1em;
        }

        #summaryRow td.domain-name {
            color: #d3869b;
        }
    </style>
</head>

<body>
    <h1>
        Live Crawler Stats
        <span id="runningTimer">Uptime: Fetching...</span>
    </h1>
    <table id="statsTable">
        <tbody id="statsTableBody"> {# Initial rows rendered by server, updated by JS #}
            {# Data rows will be populated here by JS or server, after summary and new header #}
            {% for row in rows %}
            <tr data-domain="{{ row.domain }}">
                <td class="domain-name">{{ row.domain }}</td>
                <td class="stat-html">{{ row.html | default(0) }}</td>
                <td class="stat-pdf">{{ row.pdf | default(0) }}</td>
                <td class="stat-ical">{{ row.ical | default(0) }}</td>
                <td class="stat-errors">{{ row.errors | default(0) }}</td>
                <td class="stat-empty">{{ row.empty | default(0) }}</td>
                <td class="stat-ignored">{{ row.ignored | default(0) }}</td>
                <td class="stat-bytes">{{ row.bytes_str | default("0 Bytes") }}</td>
            </tr>
            {% endfor %}
            {# Summary Row - initially rendered here, will be moved by JS #}
            <tr id="summaryRow">
                <td class="domain-name">SUMMARY</td>
                <td id="summaryHtml">{{ summary.html | default(0) }}</td>
                <td id="summaryPdf">{{ summary.pdf | default(0) }}</td>
                <td id="summaryIcal">{{ summary.ical | default(0) }}</td>
                <td id="summaryErrors" class="stat-errors">{{ summary.errors | default(0) }}</td>
                <td id="summaryEmpty">{{ summary.empty | default(0) }}</td>
                <td id="summaryIgnored">{{ summary.ignored | default(0) }}</td>
                <td id="summaryBytes">{{ summary.bytes_str | default("0 Bytes") }}</td>
            </tr>
        </tbody>
    </table>

    <script>
        const statsTableBodyEl = document.getElementById("statsTableBody");
        const summaryRowElement = document.getElementById("summaryRow");
        const runningTimerElement = document.getElementById('runningTimer');

        const statKeys = ["html", "pdf", "ical", "errors", "empty", "ignored", "bytes"];
        let scraperStartTime = null;
        let timerIntervalId = null;

        function formatBytes(bytes, decimals = 1) {
            if (bytes === 0) return '0 Bytes';
            if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) return 'N/A';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        function formatDuration(totalSeconds) {
            if (totalSeconds < 0) totalSeconds = 0;
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = Math.floor(totalSeconds % 60);

            const paddedMinutes = String(minutes).padStart(2, '0');
            const paddedSeconds = String(seconds).padStart(2, '0');

            if (hours > 0) {
                return `${String(hours).padStart(2, '0')}:${paddedMinutes}:${paddedSeconds}`;
            } else {
                return `${paddedMinutes}:${paddedSeconds}`;
            }
        }

        function updateRunningTimer() {
            if (!scraperStartTime || !runningTimerElement) {
                return;
            }

            const now = new Date();
            const durationSeconds = Math.floor((now.getTime() - scraperStartTime.getTime()) / 1000);
            runningTimerElement.textContent = `Uptime: ${formatDuration(durationSeconds)}`;
        }

        async function fetchAndUpdateStats() {
            try {
                const response = await fetch('/stats');
                if (!response.ok) {
                    console.error('Failed to fetch stats:', response.status, await response.text());
                    if (runningTimerElement) runningTimerElement.textContent = 'Uptime: Error';
                    return;
                }
                const statsData = await response.json();

                if (!scraperStartTime && statsData.start_time_iso) {
                    scraperStartTime = new Date(statsData.start_time_iso);
                    if (timerIntervalId) clearInterval(timerIntervalId);
                    timerIntervalId = setInterval(updateRunningTimer, 1000);
                    updateRunningTimer();
                } else if (!scraperStartTime && runningTimerElement) {
                    runningTimerElement.textContent = 'Uptime: Waiting...';
                }

                const receivedDomains = new Set();

                if (statsData.per_domain) {
                    const sortedDomains = Object.keys(statsData.per_domain).sort();

                    for (const domain of sortedDomains) {
                        receivedDomains.add(domain);
                        const domainData = statsData.per_domain[domain];
                        let row = statsTableBodyEl.querySelector(`tr[data-domain="${domain}"]`);

                        if (!row) {
                            row = document.createElement('tr');
                            row.setAttribute('data-domain', domain);
                            row.innerHTML = `
                                <td class="domain-name">${domain}</td>
                                <td class="stat-html">0</td>
                                <td class="stat-pdf">0</td>
                                <td class="stat-ical">0</td>
                                <td class="stat-errors">0</td>
                                <td class="stat-empty">0</td>
                                <td class="stat-ignored">0</td>
                                <td class="stat-bytes">0 Bytes</td>
                            `;
                            let inserted = false;
                            const existingDataRows = statsTableBodyEl.querySelectorAll("tr[data-domain]");
                            for (let i = 0; i < existingDataRows.length; i++) {
                                if (domain.localeCompare(existingDataRows[i].dataset.domain) < 0) {
                                    statsTableBodyEl.insertBefore(row, existingDataRows[i]);
                                    inserted = true;
                                    break;
                                }
                            }
                            if (!inserted) {
                                statsTableBodyEl.appendChild(row);
                            }
                        }

                        statKeys.forEach(key => {
                            const cell = row.querySelector(`.stat-${key}`);
                            if (cell) {
                                let newValue;
                                const rawValue = domainData[key] || 0;
                                if (key === "bytes") {
                                    newValue = formatBytes(rawValue);
                                } else {
                                    newValue = String(rawValue);
                                }
                                if (cell.textContent !== newValue) {
                                    cell.textContent = newValue;
                                }
                            }
                        });
                    }
                }

                const currentDataRows = statsTableBodyEl.querySelectorAll("tr[data-domain]");
                currentDataRows.forEach(row => {
                    if (!receivedDomains.has(row.dataset.domain)) {
                        row.remove();
                    }
                });

                statKeys.forEach(key => {
                    const summaryCellId = `summary${key.charAt(0).toUpperCase() + key.slice(1)}`;
                    const summaryCell = document.getElementById(summaryCellId);
                    if (summaryCell) {
                        let newValue;
                        const rawValue = statsData.global[key] || 0;
                        if (key === "bytes") {
                            newValue = formatBytes(rawValue, 2);
                        } else {
                            newValue = String(rawValue);
                        }
                        if (summaryCell.textContent !== newValue) {
                            summaryCell.textContent = newValue;
                        }
                    }
                });

            } catch (error) {
                console.error('Error fetching or updating stats:', error);
                if (runningTimerElement) runningTimerElement.textContent = 'Uptime: Error';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            if (!statsTableBodyEl) {
                console.error("statsTableBodyEl not found!");
                return;
            }
            if (!runningTimerElement) {
                console.warn("runningTimerElement with id 'runningTimer' not found in H1. Timer will not be displayed.");
            }

            if (summaryRowElement && summaryRowElement.parentNode === statsTableBodyEl) {
                if (statsTableBodyEl.firstChild) {
                    statsTableBodyEl.insertBefore(summaryRowElement, statsTableBodyEl.firstChild);
                } else {
                    statsTableBodyEl.appendChild(summaryRowElement);
                }
            } else if (summaryRowElement) {
                statsTableBodyEl.prepend(summaryRowElement);
            } else {
                console.warn("summaryRowElement not found! Table layout might be affected.");
            }


            const headerRow = document.createElement('tr');
            headerRow.classList.add('dynamic-header-row');
            const headers = ["Domain", "HTML", "PDF", "iCal", "Errors", "Empty", "Ignored", "Bytes"];

            headers.forEach(headerText => {
                const cell = document.createElement('td');
                cell.textContent = headerText;
                headerRow.appendChild(cell);
            });

            if (summaryRowElement && summaryRowElement.parentNode === statsTableBodyEl) {
                if (summaryRowElement.nextSibling) {
                    statsTableBodyEl.insertBefore(headerRow, summaryRowElement.nextSibling);
                } else {
                    statsTableBodyEl.appendChild(headerRow);
                }
            } else if (statsTableBodyEl.firstChild) {
                statsTableBodyEl.insertBefore(headerRow, statsTableBodyEl.firstChild);
            } else {
                statsTableBodyEl.appendChild(headerRow);
            }

            fetchAndUpdateStats();
            setInterval(fetchAndUpdateStats, 1000);
        });
    </script>
</body>

</html>
