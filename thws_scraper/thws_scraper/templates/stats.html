<!DOCTYPE html>
<html>

<head>
    <title>Live Crawler Stats (Dark - All Metrics)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #282c34;
            color: #abb2bf;
            font-size: 0.9em;
        }

        h1 {
            color: #61afef;
            border-bottom: 1px solid #444851;
            padding-bottom: 10px;
            margin-top: 0;
            display: flex;
            /* For button alignment */
            justify-content: space-between;
            /* For button alignment */
            align-items: center;
            /* For button alignment */
        }

        h1 button {
            /* Style for the new button */
            background-color: #61afef;
            color: #282c34;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
        }

        h1 button:hover {
            background-color: #5298d8;
        }


        table {
            border-collapse: collapse;
            width: 100%;
            border: 1px solid #444851;
        }

        th,
        td {
            border: 1px solid #444851;
            padding: 6px 8px;
            text-align: center;
        }

        th:first-child,
        td:first-child {
            text-align: left;
            min-width: 150px;
        }

        th {
            background-color: #353a43;
            color: #e5c07b;
        }

        tr:hover {
            background-color: #3e4451;
        }

        .domain-name {
            color: #98c379;
            font-weight: bold;
        }

        /* REMOVED Color styling for .stat-errors.has-errors and .stat-errors.no-errors */
        /* If you had .stat-errors.has-errors { font-weight: bold; } and want to keep it, add it back here without color */
        .stat-errors.has-errors {
            /* font-weight: bold; /* Example: Keep bolding if desired, but no color */
        }


        #summaryRow td {
            font-weight: bold;
            color: #c678dd;
        }

        /* REMOVED Color styling for #summaryRow .stat-errors.has-errors and .stat-errors.no-errors */


        /* CSS for collapsed table state */
        #statsTable tbody.collapsed tr[data-domain] {
            display: none;
        }
    </style>
</head>

<body>
    <h1>
        Live Crawler Stats
        <button id="toggleTableBtn">Collapse</button>
    </h1>
    <table id="statsTable">
        <thead>
            <tr>
                <th>Domain</th>
                <th>HTML</th>
                <th>PDF</th>
                <th>iCal</th>
                <th>Errors</th>
                <th>Empty</th>
                <th>Ignored</th>
                <th>Bytes</th>
            </tr>
        </thead>
        <tbody id="statsTableBody"> {# Initial rows rendered by server, updated by JS #}
            {% for row in rows %}
            <tr data-domain="{{ row.domain }}">
                <td class="domain-name">{{ row.domain }}</td>
                <td class="stat-html">{{ row.html | default(0) }}</td>
                <td class="stat-pdf">{{ row.pdf | default(0) }}</td>
                <td class="stat-ical">{{ row.ical | default(0) }}</td>
                <td class="stat-errors">{{ row.errors | default(0) }}</td>
                <td class="stat-empty">{{ row.empty | default(0) }}</td>
                <td class="stat-ignored">{{ row.ignored | default(0) }}</td>
                <td class="stat-bytes">{{ row.bytes_str | default("0 Bytes") }}</td>
            </tr>
            {% endfor %}
            {# Summary Row #}
            <tr id="summaryRow">
                <td class="domain-name">SUMMARY</td>
                <td id="summaryHtml">{{ summary.html | default(0) }}</td>
                <td id="summaryPdf">{{ summary.pdf | default(0) }}</td>
                <td id="summaryIcal">{{ summary.ical | default(0) }}</td>
                <td id="summaryErrors" class="stat-errors">{{ summary.errors | default(0) }}</td>
                <td id="summaryEmpty">{{ summary.empty | default(0) }}</td>
                <td id="summaryIgnored">{{ summary.ignored | default(0) }}</td>
                <td id="summaryBytes">{{ summary.bytes_str | default("0 Bytes") }}</td>
            </tr>
        </tbody>
    </table>

    <script>
        const statsTableBodyEl = document.getElementById("statsTableBody"); // Use the new tbody ID
        const summaryRowElement = document.getElementById("summaryRow");
        const toggleTableBtn = document.getElementById('toggleTableBtn'); // Get the button

        const statKeys = ["html", "pdf", "ical", "errors", "empty", "ignored", "bytes"];

        function formatBytes(bytes, decimals = 1) {
            if (bytes === 0) return '0 Bytes';
            if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) return 'N/A';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        async function fetchAndUpdateStats() {
            try {
                const response = await fetch('/stats');
                if (!response.ok) {
                    console.error('Failed to fetch stats:', response.status, await response.text());
                    return;
                }
                const statsData = await response.json();
                const receivedDomains = new Set();

                if (statsData.per_domain) {
                    const sortedDomains = Object.keys(statsData.per_domain).sort();

                    for (const domain of sortedDomains) {
                        receivedDomains.add(domain);
                        const domainData = statsData.per_domain[domain];
                        let row = statsTableBodyEl.querySelector(`tr[data-domain="${domain}"]`);

                        if (!row) {
                            row = document.createElement('tr');
                            row.setAttribute('data-domain', domain);
                            row.innerHTML = `
                                <td class="domain-name">${domain}</td>
                                <td class="stat-html">0</td>
                                <td class="stat-pdf">0</td>
                                <td class="stat-ical">0</td>
                                <td class="stat-errors">0</td> <td class="stat-empty">0</td>
                                <td class="stat-ignored">0</td>
                                <td class="stat-bytes">0 Bytes</td>
                            `;
                            let inserted = false;
                            const existingRows = statsTableBodyEl.querySelectorAll("tr[data-domain]");
                            for (let i = 0; i < existingRows.length; i++) {
                                if (domain.localeCompare(existingRows[i].dataset.domain) < 0) {
                                    statsTableBodyEl.insertBefore(row, existingRows[i]);
                                    inserted = true;
                                    break;
                                }
                            }
                            if (!inserted) {
                                statsTableBodyEl.insertBefore(row, summaryRowElement);
                            }
                        }

                        statKeys.forEach(key => {
                            const cell = row.querySelector(`.stat-${key}`);
                            if (cell) {
                                let newValue;
                                const rawValue = domainData[key] || 0;

                                if (key === "bytes") {
                                    newValue = formatBytes(rawValue);
                                } else {
                                    newValue = String(rawValue);
                                }

                                if (cell.textContent !== newValue) {
                                    cell.textContent = newValue;
                                }

                                // REMOVED logic for adding/removing 'has-errors'/'no-errors' classes for styling
                                // if (key === "errors") { ... }
                            }
                        });
                    }
                }

                const currentRows = statsTableBodyEl.querySelectorAll("tr[data-domain]");
                currentRows.forEach(row => {
                    if (!receivedDomains.has(row.dataset.domain)) {
                        row.remove();
                    }
                });

                statKeys.forEach(key => {
                    const summaryCellId = `summary${key.charAt(0).toUpperCase() + key.slice(1)}`;
                    const summaryCell = document.getElementById(summaryCellId);
                    if (summaryCell) {
                        let newValue;
                        const rawValue = statsData.global[key] || 0;

                        if (key === "bytes") {
                            newValue = formatBytes(rawValue, 2);
                        } else {
                            newValue = String(rawValue);
                        }

                        if (summaryCell.textContent !== newValue) {
                            summaryCell.textContent = newValue;
                        }
                        // REMOVED logic for adding/removing 'has-errors'/'no-errors' classes for styling from summary
                        // if (key === "errors") { ... }
                    }
                });

            } catch (error) {
                console.error('Error fetching or updating stats:', error);
            }
        }

        // Event listener for the toggle button
        toggleTableBtn.addEventListener('click', () => {
            const isCollapsed = statsTableBodyEl.classList.toggle('collapsed');
            toggleTableBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
        });

        // Initial fetch and interval
        setInterval(fetchAndUpdateStats, 1000);
        document.addEventListener('DOMContentLoaded', () => {
            fetchAndUpdateStats();
            // Set initial button text assuming table is expanded by default
            if (statsTableBodyEl.classList.contains('collapsed')) {
                toggleTableBtn.textContent = 'Expand';
            } else {
                toggleTableBtn.textContent = 'Collapse';
            }
        });
    </script>
</body>

</html>
